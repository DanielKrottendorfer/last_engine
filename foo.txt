#[derive(Debug, Clone)] pub struct CHAINED_ECS { pub ve_soa : Ve } impl
CHAINED_ECS
{
    pub fn new() -> Self
    {
        let mut ve_soa = Ve :: default() ; ve_soa.free_head = usize :: MAX ;
        CHAINED_ECS { ve_soa }
    } fn delete_ve_soa(& mut self, key : & Key) -> Option < Entity >
    {
        let mut ve_lock = self.ve_soa.ve.write().ok() ? ; let mut
        generation_lock = self.ve_soa.generation.write().ok() ? ; let mut
        entity_state_lock = self.ve_soa.entity_state.write().ok() ? ; let g =
        generation_lock.get(key.index) ? ; let e =
        entity_state_lock.get(key.index) ? ; if * g == key.generation && * e
        == EntityState :: Occupied
        {
            let mut e = Entity
            { ve : None, entity_type : key.entity_type.clone() } ; e.ve =
            Some(ve_lock [key.index].clone()) ; entity_state_lock [key.index]
            = EntityState :: Free { next_free : self.ve_soa.free_head } ;
            self.ve_soa.free_head = key.index ; Some(e)
        } else { None }
    } pub fn add_ve_soa(& mut self, ve : Vector3 < f32 >,) -> Option < Key >
    {
        let mut ve_lock = self.ve_soa.ve.write().ok() ? ; let mut
        generation_lock = self.ve_soa.generation.write().ok() ? ; let mut
        entity_state_lock = self.ve_soa.entity_state.write().ok() ? ; let
        free_head = self.ve_soa.free_head ; if free_head == usize :: MAX
        {
            ve_lock.push(ve) ; generation_lock.push(0) ;
            entity_state_lock.push(EntityState :: Occupied) ;
            Some(Key
            {
                index : entity_state_lock.len() - 1, generation : 0,
                entity_type : EntityType :: Ve
            })
        } else
        {
            ve_lock [free_head] = ve ; generation_lock [free_head] += 1 ; let
            t = if let EntityState :: Free { next_free } = entity_state_lock
            [free_head] { next_free } else
            { panic! ("free_head is fucked") ; } ; entity_state_lock
            [free_head] = EntityState :: Occupied ; self.ve_soa.free_head = t
            ;
            Some(Key
            {
                index : free_head, generation : generation_lock [free_head],
                entity_type : EntityType :: Ve
            })
        }
    } pub fn delete(& mut self, key : & Key) -> Option < Entity >
    {
        match key.entity_type
        { EntityType :: Ve => { self.delete_ve_soa(key) } }
    }
} pub struct Entity
{ ve : Option < Vector3 < f32 >>, entity_type : EntityType }
#[derive(Debug, Clone, Copy)] pub enum EntityType { Ve }
#[derive(Debug, Clone)] pub struct Key
{ index : usize, generation : u32, entity_type : EntityType }
#[derive(Debug, PartialEq, Eq)] pub enum EntityState
{ Free { next_free : usize }, Occupied } #[derive(Default, Debug, Clone)] pub
struct Ve
{
    ve : Arc < RwLock < Vec < Vector3 < f32 >> > >, generation : Arc < RwLock
    < Vec < u32 >> >, entity_state : Arc < RwLock < Vec < EntityState >> >,
    free_head : usize
} #[derive(Debug)] pub struct VeSysAccessor
{
    ve : [Arc < RwLock < Vec < Vector3 < f32 >> > > ; 1usize], generations :
    [Arc < RwLock < Vec < u32 >> > ; 1usize], entity_states :
    [Arc < RwLock < Vec < EntityState >> > ; 1usize],
} impl VeSysAccessor
{
    pub fn lock(& mut self) -> VeSysLock
    {
        VeSysLock
        {
            ve : [self.ve [0usize].read().unwrap()], entity_types :
            [EntityType :: Ve], generations :
            [self.generations [0usize].read().unwrap()], entity_states :
            [self.entity_states [0usize].read().unwrap()],
        }
    }
} #[derive(Debug)] pub struct VeSysLock < 'a >
{
    ve : [RwLockReadGuard < 'a, Vec < Vector3 < f32 >> > ; 1usize],
    entity_types : [EntityType ; 1usize], generations :
    [RwLockReadGuard < 'a, Vec < u32 >> ; 1usize], entity_states :
    [RwLockReadGuard < 'a, Vec < EntityState >> ; 1usize],
} impl < 'a > VeSysLock < 'a >
{
    pub fn iter < 'b > (& 'b mut self) -> VeSysIterator < 'a, 'b >
    {
        VeSysIterator
        {
            ve : & mut self.ve, entity_types : & self.entity_types,
            generations : & self.generations, entity_states : &
            self.entity_states, i : 0, y : 0
        }
    } pub fn get < 'b > (& 'b mut self, key : Key) -> Option <
    (& 'a Vector3 < f32 >) >
    {
        let i = match key.entity_type
        { EntityType :: Ve => { 0usize } _ => return None } ; if
        self.entity_states [i] [key.index] == EntityState :: Occupied
        {
            if self.generations [i] [key.index] == key.generation
            {
                let ve = self.ve [i].as_ptr() ; unsafe
                { Some((& * ve.add(key.index))) }
            } else { None }
        } else { None }
    }
} #[derive(Debug)] pub struct VeSysIterator < 'a, 'b >
{
    ve : & 'b mut [RwLockReadGuard < 'a, Vec < Vector3 < f32 >> > ; 1usize],
    entity_types : & 'b [EntityType ; 1usize], generations : & 'b
    [RwLockReadGuard < 'a, Vec < u32 >> ; 1usize], entity_states : & 'b
    [RwLockReadGuard < 'a, Vec < EntityState >> ; 1usize], i : usize, y :
    usize
} impl < 'a, 'b > Iterator for VeSysIterator < 'a, 'b >
{
    type Item = (& 'a Vector3 < f32 >) ; fn next(& mut self) -> Option < Self
    :: Item >
    {
        loop
        {
            while self.entity_states [self.i].len() <= self.y
            {
                self.y = 0 ; self.i += 1 ; if self.i ==
                self.entity_states.len() { return None }
            } match self.entity_states [self.i] [self.y]
            {
                EntityState :: Occupied => break, EntityState :: Free { .. }
                => self.y += 1
            } ;
        } let temp =
        {
            let ve = self.ve [self.i].as_ptr() ; unsafe
            { Some((& * ve.add(self.y))) }
        } ; self.y += 1 ; temp
    }
} impl CHAINED_ECS
{
    pub fn get_ve_sys_accessor(& self) -> VeSysAccessor
    {
        VeSysAccessor
        {
            ve : [self.ve_soa.ve.clone()], generations :
            [self.ve_soa.generation.clone()], entity_states :
            [self.ve_soa.entity_state.clone()]
        }
    }
} impl Ve
{
    pub fn lock(& mut self) -> VeLock
    {
        VeLock
        {
            ve : self.ve.write().unwrap(), generation :
            self.generation.read().unwrap(), entity_state :
            self.entity_state.read().unwrap(),
        }
    }
} pub struct VeLock < 'a >
{
    ve : RwLockWriteGuard < 'a, Vec < Vector3 < f32 >> >, generation :
    RwLockReadGuard < 'a, Vec < u32 >>, entity_state : RwLockReadGuard < 'a,
    Vec < EntityState >>
} impl < 'a > VeLock < 'a >
{
    pub fn iter < 'b > (& 'b mut self) -> VeIterator < 'a, 'b >
    {
        VeIterator
        {
            ve : & mut self.ve, generation : & mut self.generation,
            entity_state : & mut self.entity_state, i : 0
        }
    } pub fn get < 'b > (& 'b mut self, key : & Key) -> Option <
    (& 'a Vector3 < f32 >) >
    {
        if * self.generation.get(key.index) ? == key.generation
        {
            let ve = self.ve.as_mut_ptr() ; unsafe
            { Some((& mut * ve.add(key.index))) }
        } else { None }
    }
} pub struct VeIterator < 'a, 'b >
{
    ve : & 'b mut RwLockWriteGuard < 'a, Vec < Vector3 < f32 >> >, generation
    : & 'b mut RwLockReadGuard < 'a, Vec < u32 >>, entity_state : & 'b mut
    RwLockReadGuard < 'a, Vec < EntityState >>, i : usize,
} impl < 'a, 'b > Iterator for VeIterator < 'a, 'b >
{
    type Item = (& 'a mut Vector3 < f32 >, Key) ; fn next(& mut self) ->
    Option < Self :: Item >
    {
        loop
        {
            if self.i == self.entity_state.len() { return None ; } match
            self.entity_state [self.i]
            {
                EntityState :: Occupied => break, EntityState :: Free { .. }
                => self.i += 1
            }
        } let temp =
        {
            let key = Key
            {
                index : self.i, generation : self.generation [self.i],
                entity_type : EntityType :: Ve
            } ; let ve = self.ve.as_mut_ptr() ; unsafe
            { Some((& mut * ve.add(self.i), key)) }
        } ; self.i += 1 ; temp
    }
} impl CHAINED_ECS { pub fn get_ve(& mut self) -> Ve { self.ve_soa.clone() } }